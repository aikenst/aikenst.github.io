# Chapter 2.1 変数

変数はコードを書く際にコードを簡潔にしさらに見やすくしてくれるものです。例えば足し算を行い時に`374694`みたいな大きな数を毎回プログラムに書いて足し算を行うのはかなりめんどくさくなってしまいますしコードが見づらくなってしまいます。

ここでその問題を解決してくれるのが**変数**です。
```rust,noplayground
let x = 374694; //let 変数名 = 値;
```
変数の定義の仕方は上記のように定義し"//"以降が変数を定義するときの基本的な形になります。このとき名前が値に**束縛**されたと言います(変数`x`が374694に束縛された)。

>`//`は**コメント**といい`//`以降の部分をコードの実行において無視してくれるようになります。なので`//`を使用することでコードにメモを残すことができます。また`/* */`のようにすることで複数行のコメントを残すことができます。

また、文の最後のセミコロン(`;`)を忘れないようにしましょう。これを忘れるとプログラムを実行するときにエラーになってしまいます。このように変数を定義すると足し算をする際に`x`という値を使うだけで`374694`この値で計算することができます。もう一つ何か大きな値を定義して足し算を比較してみましょう。
```rust
fn main(){
    let x = 374694;
    let y = 457979;

    let s = x+y;
    let t = 374694 + 457979;    
    println!("sの値は{} tの値は{}",s,t);
}
```
`s`と`t`の値を見比べた際にどちらが見やすいかは明らかだと思います。またこの計算を複数回行うならより変数の便利さや見やすさに気づくと思います。

>変数やこの後に紹介する定数はブロック内(`{}`内）を出ると使えなくなるので中止してください

ただこの変数は値を変えることができません。どういうことか見てみましょう。
```rust
fn main() {
    let x = 1;
    println!("xの値は{}",x);//xの値をプログラムの結果として表示しようとしている
    //("")内の{}は後ろのxの値が入る場所です 
    x = 2;
    println!("xの値は{}",x);

}
```
このコードでは`x`の値を1で定義してその後2という値に変えようとし、そして`x`の値を表示しようとしています。では実際に動きを見てましょう。このコードにカーソルを合わせると右上に![再生ボタン](../img/%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88.png)が表示されるはずなので押して見ましょう。下のようなエラーが出てくると思います。
```
   Compiling playground v0.0.1 (/playground)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 1;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("xの値は{}",x);//xの値をプログラムの結果として表示しようとしている
4 |     x = 2;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `playground` due to previous error
```
このように正しいプログラムでないとコンパイラがエラーを見つけわかりやすくエラーの場所を表示してくれます。error[E0384]: cannot assign twice to immutable variable x (不変変数`x`に二回代入できません)この文がエラーの内容になります。

Rustでは変数を宣言したら値が変わらないことをコンパイラが保証します。しかし何か条件に満たすものを数えたい時など変数の値を変えたい瞬間が出てきます。その時に使うのが`mut`というキーワードです。これを`let`と変数名の間につけることで変数の値を可変にしてくれます。先程のコードの変数`x`を可変なものにし、出力してみましょう。(//の部分は書かなくて大丈夫です)
```rust,editable
fn main(){

}
```
出力結果が下記のようになれば成功です。
```
xの値は1
xの値は2
```
また変数の定義だけを行なって、後から値を入れたい時には`mut`が必要ありません。
```rust
fn main(){
    let x;
    x=1;//mutなしで値を決めれる　エラーも出ない
    println!("hello world");
}
```

>自分のPC上でRustを動かす際に変数を定義して使わないと実行時に警告(warning)が出てしまうので注意してください。[Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021)に上のコードを貼り付けて実行すると実行結果は出てきますが警告も出てきます(このドキュメント内で実行すると警告が表示されません)。このような変数を定義したけど使わない時にはアンダースコア(_)を変数名の先頭につけるとこの警告が出なくなります。警告は出てきてもプログラムは実行できますが安全性に欠けるので無くしましょう。

ここまで変数の不変性、可変性について説明してきました。不変な変数に似ているものとして**定数**があります。定数は不変変数のように名前に束縛され、変更することができません。しかしいくつかの違いがあります。
* 定数には`mut`が使えない(常に不変である)
* 定数を宣言する際には`let`ではなく`const`を用いる。値の型は**必ず**注釈しなけれななりません。型や型の注釈については[2.2. 型](./chapter_2_2.md)で説明します。
* 定数はどんな場所でも定義できる。`fn main( ){ }`の外でも定義できる。
* 定数は決められた値でしか定義できない。実行時に評価される値は使えない(足し算の結果などを定数にすることができない)。

定数の定義の例を見ましょう
```rust
const MAX_SPEED: u32 = 100;//変数名 : 型　この形が型注釈

fn main(){
    let x = 100;
    let y = x + MAX_SPEED;

    println!("yの値は{}",y);
}
```

Rustでは定数の名前を全て大文字でアンダースコア(`_`)で単語区切りすることを習慣としています。よく定数はゲームの中で色々な場所に使う値(敵を倒した時のスコアなど)を定義するときによく使われます。

### シャドーイング

Rustでは一度定義した変数と同じ名前の変数を定義することができます。これを**シャドーイング**と言います。シャドーイングされた場合は後の方の変数の値が処理に使われます。
```rust
fn main(){
    let x = 10;
    println!("xの値は{}",x);

    let x = x + 1;//シャドーイング
    {
        let x = 1;
        println!("xの値は{}",x);
    }
    println!("xの値は{}",x);
}
```
このコードを実行してみましょう。このコードでは最初`x`を10に束縛していますが`let x = x + 1;`ここでシャドーイングをしています。ここでは`x`という同じ変数名で元の値に`+1`した値に束縛しています。二つ目の`{}`内でまたシャドーイングしていますがこの`{}`内を抜けると中で定義されたものは無効になるので`let x = x + 1;`の値になります。

このシャドーイングは変数に`mut`をつけるのとは異なります。元は不変な変数なので`let`を使わずに値を変えようとするとエラーになります。また、`mut`をつける方法では宣言した変数の型を変えることはできません。下記のようなものはエラーになってしまいます。
```rust
fn main(){
    let mut a = 5;//数値型
    a="hello world";//文字列型
    println!("aの値は{}",a);
}
```
逆にシャドーイングを利用すれば型の変更を行うことができます。
```rust
fn main(){
    let a = 5;
    let a="hello world";
    println!("aの値は{}",a);
}
```
これで変数の定義方法等を見ていったので今度は変数の型について見ていきます。