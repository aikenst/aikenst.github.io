# chapter 2.2 型
Rustにおいて値は全て何かしらのデータ型になります。前の章などで`i32`や`u32`などいくつか見たことがあると思います。これらが型を表したものになります。この型がわかることでコンパイラがどんなデータかわかり取り扱い方を決めれます。データ型にはスカラー型と複合型があります。また同じ型でないと計算などが行えないので注意してください(`u32`と`u8`なども計算できない)。

## スカラー型
スカラー型は単一の値のことを表しています。Rustには整数、浮動小数点数、論理値や文字列の4つのスカラー型があります。

#### 整数型
整数型は少数部分がない数値のことです。今まで出てきたu32やi32がこれに当たります。下記の表がそれぞれ表せれる数字の範囲になります。プログラムを書く際に必要になる値が入っている値を型を使いましょう。特に気にする必要がない場合はRustの基準型を使うといいでしょう。整数型の基準は`i32`です。この基準型が一番実行する上で速いです。

| 大きさ | 符号付き | 表せれる数字                             | 符号なし | 表せれる数字           | 
| :----: | :------: | :--------------------------------------: | :------: | :--------------------: | 
| 8bit   | i8       | -128~127                                 | u8       | 0~255                  | 
| 16bit  | i16      | -32768~32767                             | u16      | 0~65535                | 
| 32bit  | i32      | -2147483648~2147483647                   | u32      | 0~4294967295           | 
| 64bit  | i64      | -9223372036854775808~9223372036854775807 | u64      | 0~18446744073709551615 | 
| arch   | isize    |                                          | usize    |                        | 

`isize`や`usize`はコンピュータの種類による値になります。64ビットアーキテクチャなら64ビットに32ビットアーキテクチャなら32ビットになります。

また数字を他の方法で表すこともできます。

| 数値リテラル   | 例          | 
| :------------: | :---------: | 
| 10進数         | 32_112      | 
| 16進数         | 0xf3        | 
| 8進数          | 0o71        | 
| 2進数          | 0b1111_0000 | 
| バイト(u8のみ) | b'A'        | 

リテラルは見たままの値という意味です。アンダースコア(_)は見た目の区切り文字として使用できます。(10,000の`,`と同じ役割)

### 浮動小数点数
浮動小数点型には`f32`と`f64`があります。整数型と同じくこれは32ビットと64ビットです。浮動小数点数はIEEE-754規格に従って表現されます（興味があれば調べて見てください）。Rustでの基準型は`f64`の方でこちらの方が精度が高く`f32`と速度がほぼ変わらないのでこちらが使われます。

```rust 
fn main() {
    let x : f64 = 32.2;
    println!("xの値は{}",x);
}
```
### 論理値型
論理値型がとる値は二つしかありません。`true`と`false`の二種類だけです。論理値を使うのは条件式で主に使われます。条件式は3章に出てきます。論理値型を明示したい時は`bool`を使います。
```rust,noplayground
fn main() {
    let t = true;

    let f: bool = false; 
}
```

### 文字型
Rustで文字を扱いたい時にはこの型(`char`型)が使われます。文字列を扱うものは少し複雑なのでこのドキュメントの後の方で触れていきます。

`char`型は一文字を扱う時に使用します。`char`型はユニコードのスカラー値というものを表しています。これによりアルファベットだけでなく日本語や絵文字なども表すことができます。
```rust
fn main() {
    let a = 'a';
    let b = 'あ';
    let heart_eyed = '😻';   
    println!("aの値{}　bの値{}　絵文字の出力{}",a,b,heart_eyed);
}

```

## 複合型
複合型とは複数の値を一つの型にまとめるものです。タプルと配列という二種類があります。

### タプル型
タプルは複数の型の値を一つにまとめれるものです。要素の数は定義後は変えれません。要素の値は`mut`をつけ可変にすることで値を変えれます。

タプルは`()`の中にカンマ(`,`)で区切り、値を書くことで生成できます。
```rust,noplayground
fn main(){
    let tup = (100,"hello",true);
}
```
変数`tup`はタプル全体に束縛されています。このタプルから個々の要素を取り出したい時にはパターンマッチングというのを使用して取り出すことができます(後の章で説明します)。
```rust
fn main(){
    let tup = (100,"hello",true);
    let (a, b, c) = tup;
    println!("aの値{}　bの値は{}　cの値{}",a,b,c);
}
```
二行目でパターンマッチングを使用してタプルの値をそれぞれ`a,b,c`の三つの変数に分配しています。

この分配する方法以外にもアクセスしたい番号をピリオド(`.`)に続けて書くことでタプルの要素に直接アクセスすることができます。この番号のスタートは0からなのに注意してください。タプルの一つ目の要素にアクセスしたい場合は使う番号は0になります。また要素数を超えてアクセスしようとするとコンパイル時にエラーになります。それでは、例に倣って5つ目の要素にアクセスする変数を定義し、変数aと自分が定義した変数を表示するように下のプログラムを追加してみましょう。
```rust,editable
fn main(){
    let tup = (100,"hello",true,400,"world");
    let a = tup.0;//一つ目の要素にアクセス


}
```

### 配列型
配列もタプルと同様に複数の値を一つにまとめてくれるものです。またタプルと同様に要素数は定義後は固定です。タプルと異なる点はまとめる値が全て同じ型でなければなりません。

配列は`[]`の中にカンマ(,)区切りの値を書くことで生成できます。
```rust
fn main(){
    let x = [1,2,3,4,5];
    let [a,b,c,d,e] = x;
    println!("aの値は{}",a);
}
```
配列もタプルと同様にパターンマッチングを使うことでそれぞれの要素を取り出すこともできます。

他にもアクセスしたい場所を選択する方法として`配列名.[]`とかき`[]`の中にアクセスしたい場所の数字を書くことで配列の要素に直接アクセスすることができます。この番号もスタートは0からなのに注意してください。
```rust
fn main(){
    let a = [1,2,3,4,5];
    println!("三つの目の値は{}",a[2])//3の部分にアクセスしようとしているので番号は2
}
```
配列は常に固定長であるものに使うのに有効です。

配列の定義の仕方として違う方法もあります。`[]`の中に初期値とセミコロン(`;`)、配列の長さを与えることでも定義できます。
```rust,noplayground
fn main(){
    let a = [1;5];//[1,1,1,1,1]と同じこと
}
```
配列の要素数を超えてアクセスしようとするとコンパイルは通りますが実行時にエラーになります。これを**パニック**したと言います。プログラムがエラーで終了したことを表しています。

これまで型について説明してきました。これはRustが安全性などを保障するために必要なものなのです。Rustは**静的型付き言語**です。これはコンパイル時にすべての変数の型がわかっている必要があるということです。基本的には明示的に型を書かなくても値や使い方から推論して変数の型を決めてくれます。しかし、複数の型が推論される時や基準でない型を使いたい時( i32が基準だがi8を使いたいなど)に型を明示的に書く(**型注釈**という)必要があります。

下記のコードは型注釈をつけたものになります。
```rust
fn main(){
    let x = 8;//基準であるi32
    let y : u8 = 8;//u8の型になっている
    let tup : (i32,bool,char) = (54,true,'F');
    let a : [i8; 3] = [1,2,3];
    //下記のは.parse()というメソッドを使ってString型(文字が並んだ型)を数値型に変換している
    //42という文字を数字に変えている
    //.expect()はparse()が数字に変えれなかった時のエラーへの対応用
    let guess: u32 = "42".parse().expect("Not a number!");
    //u32を書かないとコンパイル時にエラーになる
}
```

ここまで型について説明していきました。次の章では様々な演算についてみていきましょう。
