# Chapter 4.1 所有権

全てのプログラムは実行中にコンピュータのメモリを使用し動作しています。このメモリの使用方法についてRustでは所有権という概念とメモリについてコンパイル時にチェックする規則によって管理されています。この所有権について理解することでより安全かつ効率的なコードを書くことができます。

### 所有権のルール
* Rustでは各値は所有者と呼ばれる変数と対応している
* 所有者は一つである
* 所有者がスコープから外れた時に値が棄てられる

このルールについては今までになんとなく見ています。
```rust,editable
fn main(){
    let x = {
        let y = 1;
        y + 1
    };

    let z = println!("マクロ呼び出し");//zの値は空のタプル"()"になる。

    let a = sum(3,5);

    let b = difference(7,2);

    println!("xの値{}　aの値は{} bの値は{}",x,a,b);
}

fn sum (x: i32,y: i32 ) -> i32 {
    x+y
}

fn difference (x: i32,y: i32) -> i32 {
    return x - y;
    println!("Hello world");//return以降は実行されない 警告が出るので注意
}
```
これは[3.3. 関数](../chapter3/chapter_3_3.md)で出てきたものです。xは`{}`のブロック内でyの定義を行いその値を用いて定義しています。このyの値は`{}`外で利用しようとするとエラーになります。上のコードでxの定義の後にyの値を表示するコードを追加し実行してみましょう。エラーが表示されるはずです。これはyの値が`{}`のスコープから外れ、yの値が持っている1という値がメモリから破棄されるためです。

定義したxやaなどはそれぞれ値を持った所有者となります。このコードを見てください。
```rust
fn main(){
    let x = 2;
    let y = x;
    println!("xの値は{}yの値は{}",x,y);
}
```
このコードではyの定義にxを利用しています。これはxが束縛されている2という値に対してyも同じように束縛しようとしているように見えます。これではルールにおける所有者が一つというのに反しているのでは無いでしょうか？

これは実際にはルールに反していません。その理由は、整数のようなコンパイル時にメモリに対して既知のサイズを持つ型はコピーが容易かつ高速なので代入というよりコピーされます。

Rustには`Copy`トレイトと呼ばれる特別な注釈があり、整数などの決まったサイズのものに対して配置することができるものがあります。(`Copy`トレイトなどはこの入門コースでは扱いません)型が`Copy`トレイトに適合している時、代入後も前の変数も使うことができます。`Copy`かどうかの判断としては単純なスカラー値(単純な値やそれを格納する型)であれば`Copy`でありメモリの確保が必要であったり何かのリソースが必要である場合(これから説明する`String`型など)は`Copy`ではありません。`Copy`の一部を下記に示します。

* 整数型(`u32 i32`など)
* 浮動小数点型(`f64 f32`など)
* 論理値型(`true false`)
* 文字型(`char` 一つの文字)
* タプル(`(i32,char)`など`Copy`だけで形成されているもののみ)

ここまでは所有権について特別気にしてきませんでした。ここから所有権について詳しく見ていきましょう。

### String型
`String`型は文字列の型です。今まで`char`型で一文字だけ扱いましたが`String`型はサイズが可変な文字列を扱えるようになります。

可変な文字列の前に不変な文字列である文字列リテラルについて説明します。文字列リテラルでは文字列の値をプログラムにハードコード(そのまま値を書き込むこと)します。プログラミングを始めた時に`println!("Hello world!")`を見たと思いますがこの`Hello world!`がハードコードのことです。この文字列リテラルはこれからも変わらないもの(円周率など)に対しては適しています。しかし、ユーザの入力を受けてそれを保持し、扱いたい時には適していません。このために`String`型を使います。

文字列リテラルを文字列型にするためには次のようなコードになります。
```rust
fn main(){
    let mut x = String::from("Hello"); //Helloを文字列型に変換
    x.push_str(" world");//push_str()関数は文字列リテラルをString型の後ろにつける
    println!("xの中身{}",x);
}
```
`String::from`は文字列リテラルを文字列に変換するものです。詳しくいうとString型の下にあるfrom関数を利用して文字列を生成しています。

>このコードは所有権に関連して重要な動きをしています。`String::from`関数でOSにメモリを要求しています。`String`型のような可変な文字列などコンパイル時にサイズが不明なものの実際のデータは**ヒープ**というメモリの一部に保存されます。この必要なメモリは実行時(`String::from`関数など)にOSに要求され、使用し終わったらOSにメモリを返還する必要があります。メモリの返還する方法としては所有権のルールの三つ目にあるスコープから抜ける時に値が棄てられるというルールに基づいてスコープから抜けた際に自動的にメモリも返還されます(実際には`drop`関数というものが呼ばれているがこのコースでは扱わない)。<br> <br>もう一つ所有権に対して重要なことがあります。ヒープの動きについてです。ヒープにデータを置く際には十分な大きさの空領域を確保し、そこの場所へのアドレスである**ポインタ**を返します。また複数の確保した領域は規則正しく並んでいないためヒープへのデータアクセスはポインタを追っていく必要があるためアクセスの速度が低速です。<br> <br>ヒープとよく一緒に紹介されるものとして**スタック**があります。スタックはヒープと異なりコンパイル時にサイズがわかるものを扱います(整数型など)。またデータを保存する際にはスタック領域に積んでいきます。積んでいくという表現の通り、お皿の山をイメージするといいでしょう。お皿を追加する時にはそのお皿を山の上に追加し、必要になれば山の上からとっていくというように構成されています。この追加する動作は**push**取り出す動作を**pop**と言います。またデータアクセスする際にはポインタを追う必要がなく、スタックからデータを取り出すだけなのでアクセス速度が高速です。

#### まとめ

#### ヒープ
* コンパイル時にサイズがわからないものに使う
* 動作が低速

#### スタック
* コンパイル時にサイズがわかるものに対して使う
* 動作が高速

スタックとヒープについてはメモリの確保の仕方や速度について理解していればこのコースでは十分だと思います。

<br>

ここで先ほど説明したコードを見ましょう。
```rust
fn main(){
    let x = 2;
    let y = x;
    println!("xの値は{}yの値は{}",x,y);
}
```
これは所有権について問題ないと説明したと思います。実際にはこれらはスタックに積まれるので値をコピーする処理が高速であるため所有権が移動せずコピーすることができます。

>文字列リテラルは実行時にサイズがわかっているのでスタックに保存されます。なので値もコピーすることができます。

ではヒープを扱うようなString型ではどうなるでしょうか？
```rust
fn main(){
    let s1 = String::from("Hello world");
    let s2 = s1;
    println!("s1の値は{}s2の値は{}",s1,s2);
}
```
実行してみてみましょう。エラーが出ると思います。`error[E0382]: borrow of moved value: s1`というムーブされた値s1についての借用またはborrowの部分が使用というuseになったエラーが出ます。これはs1が持っていた所有権がs2に移動した後にs1を使用したためエラーが起こるのです。やはりヒープを使う`String`型ではコピーする処理は時間がかかってしまうためコピーできません。

実際にどのような動きをしているのかみてみましょう。

![スタックとヒープ](../img/%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%81%A8%E3%83%92%E3%83%BC%E3%83%97.png)

<br>

`String`型のスタック上のデータ
* ptr<br>
ヒープ上のデータを指すポインタ

* len<br>
現在使用している文字列のメモリ量をバイトで表したもの(文字列の長さ)

* capacity<br>
OSから受け取った全メモリ量をバイトで表したもの

<br>

`String`型はヒープに実際のデータが保存されます。そして先ほどのコードのようにs2にs1を代入すると`String`型のスタック上のデータが図の左のようにコピーされヒープ上の同じデータを指すことになります。このような状態ままスコープを出るとs2とs1のポインタが指している部分を開放しようとします。これは**二重開放エラー**というメモリの安全性においてのバグになってしまいセキュリティの脆弱性を生む可能性があります。なのでRustでは確保されたメモリをコピーしようとする代わりにs1を無効化し、スコープから出た際にもメモリの解放する必要性を無くしています。このようにs1を無効化する働きをRustでは**ムーブ**と言います。今回ではs1はs2にムーブされたと言います。

ではヒープ上のデータもコピーしたい場合には`clone`メソッド(メソッドは関数と同じようなものという理解で今は大丈夫だと思います)を使います。
```rust
fn main(){
    let s1 = String::from("Hello world");
    let s2 = s1.clone();
    println!("s1の値は{} s2の値は{}",s1,s2);
}
```
`clone`メソッドを使うことでs1がムーブされることなく利用できます。ただヒープの特性上、実行速度が遅くなるなど欠点もあります。

### 関数

関数に変数を引数として渡したり、関数から値を返すことでもムーブやコピーが行われます。
```rust,editable
fn main(){
    let s1 = String::from("Hello world");
    let mut s2 = String::from("Hello world");

    take(s1);

    s2 = take_give(s2);
  
    let x = 1;
    
    copy(x);

}//s1はムーブしたのでここではs1に対しては何も起こらない

fn take(st: String){//s1がsrにムーブされる

    println!("s1の値は{}",st);

}//ここでstのメモリが解放される

fn take_give(some_st: String)-> String {

    println!("s2の値は{}",some_st);
    some_st//呼び出し元へムーブする

}

fn copy(integer: i32){//xの値がintegerにコピーされる

    println!("xの値は{}",integer);

}//ここでintegerのメモリが解放される
```
上記のコードで`take`関数や`copy`関数の後に`println!()`などを追加してs1,s2やxの値が利用できるかみてみましょう。ここでs2は値が返ってくるので可変にしています。

関数で値を扱う際に所有権を移動させずに元の値を使用できるようにする**参照**というものもあります。

## 参照

所有権を移動させずにデータへアクセスしたい時に参照をします。参照する際には参照元の前に`&`をつけます。また引数として受け取る際の型や戻り値の型にも`&`をつけます。次のコードを見てください。
```rust
fn main(){
    let s1 = String::from("Hello world");
    let s2 = &s1;

    let len = cal_len(&s1);


    println!("s1の値は{}でs1の長さは{} s1を参照したs2の値は{}",s1,len,s2);
}

fn cal_len(st: &String)-> usize{ //借用
    st.len()//len()はStringのスタック上のデータであるlenの値を返す
}
```
ここで`&s1`は`s1`への参照を生成しています。そして参照なのでスコープを抜けても指している値が棄てられることもありません。具体的には`cal_len`関数において`st`は参照をもらっているだけなので`st`がスコープを抜けても`s1`の値が棄てられません。この`(st: &String)`のように関数の引数に参照を取ることを**借用**と言います。

また参照は変数同様に通常で不変なので参照元に変更を加えようとするとエラーになります。
```rust
fn main() {
    let s = String::from("hello");

    change(&s);

}

fn change(st: &String) {
    st.push_str(" world");
}
```
不変な参照なので変更できませんというようなエラーが出てくると思います。参照も変数同様に可変にすることができます。
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);

    println!("sの値は{}",s);
}

fn change(st: &mut String) {
    st.push_str(" world");
}
```
まずは変数の値を変更するのでsの値を`mut`をつけます。そして参照する際にも`&mut s`のように`mut`をつけます。このようにすることで可変な参照をすることができます。

参照のルールとして一つのデータに対して不変な参照は複数回参照を行うことができますが可変な参照は一つしかできません。このようにすることで同時にデータの変更などを許さず、安全性を保つことができます。
```rust
fn main(){
    let mut s = String::from("hello");
    {
        let t1 = &mut s;
        t1.push_str(" world");
    }//ここでt1の値は棄てられるのでこれ以降で新しい可変な参照を使うことができる

    let t2 = &mut s;
    t2.push_str(" good morning");

    println!("sの値は{}",s);

}
```
このコードのように同時に可変な参照をしなければ複数の可変な参照をすることができます。また不変な参照と可変な参照も同時に行うことができません。
```rust
fn main(){
    let mut s = String::from("hello");

    let t1 = &mut s;
    let t2 = &s;
    println!("t1の値{}t2の値{}",t1,t2);
}
```
先ほどのようにスコープを使い区切ることで可変な参照と不変な参照を行うことができます。
```rust
fn main(){
    let mut s = String::from("hello");
    {
    let t1 = &mut s;
    t1.push_str("world");
    }

    let t2 = &s;
    println!("sの値{} t2の値{}",s,t2);
}
```
注意として不変な参照を行なった後に`{}`などで区切っても可変な参照を行うことはできません。つまりこのt1を定義する前に不変な参照を行うとエラーになります。

また参照している状態でデータの方を解放してしまうとエラーになります。具体的なコードを見ましょう。
```rust
fn main(){
    let s1 = give();
}

fn give() -> &String{
    let s = String::from("hello");

    &s
}
```
これの動作を説明すると
1. give関数を呼び出す
1. sを定義する
1. sの参照を返す
1. sが解放される
1. しかしsの参照をs1が持っている

4と5の動作が問題になっています。これは他の言語でもポインタが実装されているものであれば起こり得るエラーです。Rustでは参照がスコープを抜けるまでデータがスコープを抜けないようにチェックしてくれます。なのでこのような場合はちゃんとエラーとして表示してくれます。